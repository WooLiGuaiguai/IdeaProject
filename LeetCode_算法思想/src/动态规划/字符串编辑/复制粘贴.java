package 动态规划.字符串编辑;
//最初在一个记事本上只有一个字符 'A'。你每次可以对这个记事本进行两种操作：
//Copy All (复制全部) : 你可以复制这个记事本中的所有字符(部分的复制是不允许的)。
//Paste (粘贴) : 你可以粘贴你上一次复制的字符。
//给定一个数字 n 。你需要使用最少的操作次数，在记事本中打印出恰好 n 个 'A'。输出能够打印出 n 个 'A' 的最少操作次数。

public class 复制粘贴 {
    public static void main(String[] args) {

    }

    //当n = 1时，已经有一个A了，我们不需要其他操作，返回0
    //当n = 2时，我们需要复制一次，粘贴一次，返回2
    //当n = 3时，我们需要复制一次，粘贴两次，返回3
    //当n = 4时，这就有两种做法，一种是我们需要复制一次，粘贴三次，共4步，另一种是先复制一次，粘贴一次，得到AA，然后再复制一次，粘贴一次，得到AAAA，两种方法都是返回4
    //当n = 5时，我们需要复制一次，粘贴四次，返回5
    //当n = 6时，我们需要复制一次，粘贴两次，得到AAA，再复制一次，粘贴一次，得到AAAAAA，共5步，返回5
    //(除了1以外)，最差的情况就是用n步;小模块的长度必须要能整除n，这样可以拆分并减少步数
    public int minSteps(int n) {
        int[] dp = new int[n + 1];
        for (int i = 2; i <= n; i++) {
            dp[i] = i;
            //那么n被分成了 i 份， 比如 6 被3 除开  被分成了 3 份 每份是 2 ，那么不就是粘贴 2 的次数 就是 3 其实就是 i，毕竟被分成了i 份
            for (int j = i - 1; j > 1; j--) {
                if (i % j == 0)
                    dp[i] = Math.min(dp[i], dp[j] + i / j);
            }
        }
        return dp[n];
    }
}
