Backtracking（回溯）属于 DFS。

普通 DFS 主要用在 可达性问题 ，这种问题只需要执行到特点的位置然后返回即可。
而 Backtracking 主要用于求解 排列组合 问题，例如有 { 'a','b','c' } 三个字符，求解所有由这三个字符排列得到的字符串，
这种问题在执行到特定的位置返回之后还会继续执行求解过程。

因为 Backtracking 不是立即返回，而要继续求解，因此在程序实现时，需要注意对元素的标记问题：
在访问一个新元素进入新的递归调用时，需要将新元素标记为已经访问，这样才能在继续递归调用时不用重复访问该元素；
但是在递归返回时，需要将元素标记为未访问，因为只需要保证在一个递归链中不同时访问一个元素，可以访问已经访问过但是不在当前递归链中的元素。

回溯需要注意 比较难
List<List<Integer>> lists=new ArrayList<>();
List<Integer> list=new ArrayList<>();
将list添加到lists中时，需要使用如下表示形式：lists.add(new ArrayList<>(list));
如果直接使用lists.add(list); 会为空
因为arrayList作为方法的参数，方法结束时栈帧被回收，其中的所有内容包括局部变量表不再有效。所以result指向的list都为空。

全排列和组合总结：
1.重复数字排列和非重复数字排列的区别在于多一项判断条件：
if (i!=0 && nums[i]==nums[i-1] && !flag[i-1])
同时需要注意排序，将相同的数字放在一起
相同之处是：都需要flag来对是否访问过进行判断
2.组合和排列有显著的区别：
对于[1,2,3]来说它的排列长度一定和数组长度一致，并且[1,2,3]和[3,2,1]是两个排列情况
谈到组合，长度是小于等于数组长度的 [1],[1,2]都是组合，但是[1,2]和[2,1]是一个组合情况
3.组合解决思路是通过设置起始坐标start来确保不会有  [1,2]和[2,1]  同时存在的情况
如果数组中没有重复数字，可以重复选取，那么回溯的时候start的值依旧是i
如果数组中存在重复数字，不可以重复选取，那么先进行排序，
再增加和排列一样的判断条件if (i!=0 && nums[i]==nums[i-1] && !flag[i-1])的同时，将start的值设为i+1


解数独一题中 如果都是静态的 那么char数组不能作为参数进行传递 这样修改记录不会更新到原数组当中 应该将其单独编程为私有变量
奇怪的是，编译器可以自动解决这个问题 执行代码时也可以 但是提交就不对？

N皇后没看